#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import readline from "node:readline";
import { spawnSync } from "node:child_process";

function usage() {
  process.stdout.write(`clawscrew

Usage:
  clawscrew install [--dry-run]
  clawscrew connector [--once] [--poll-ms <ms>] [--worker-id <id>] [--auto-pass] [--execute-openclaw] [--deployment <name>] [--deploy-key <key>]
  clawscrew connector-service [--dry-run] [--deploy-key <key>] [--poll-ms <ms>] [--worker-id <id>] [--execute-openclaw] [--deployment <name>]
`);
}

function parseArgs(argv) {
  const args = { _: [] };
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--dry-run") args.dryRun = true;
    else if (a === "--once") args.once = true;
    else if (a === "--auto-pass") args.autoPass = true;
    else if (a === "--execute-openclaw") args.executeOpenclaw = true;
    else if (a === "--poll-ms") args.pollMs = Number(argv[++i] || "0");
    else if (a === "--worker-id") args.workerId = String(argv[++i] || "");
    else if (a === "--deploy-key") args.deployKey = String(argv[++i] || "");
    else if (a === "--deployment") args.deployment = String(argv[++i] || "");
    else args._.push(a);
  }
  return args;
}

function question(rl, prompt) {
  return new Promise((resolve) => rl.question(prompt, (ans) => resolve(ans)));
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function writeEnvFile(filePath, kv) {
  const lines = [];
  for (const [k, v] of Object.entries(kv)) {
    lines.push(`${k}=${v ?? ""}`);
  }
  lines.push("");
  fs.writeFileSync(filePath, lines.join("\n"), "utf8");
}

function normalizeEnvValue(v) {
  let s = String(v ?? "").trim();
  if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
    s = s.slice(1, -1).trim();
  }
  // Strip inline comments in .env values like: VALUE=abc # comment
  s = s.replace(/\s+#.*$/, "").trim();
  return s;
}

function readEnvFile(filePath) {
  if (!fs.existsSync(filePath)) return {};
  const out = {};
  const text = fs.readFileSync(filePath, "utf8");
  for (const line of text.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;
    const k = trimmed.slice(0, eq).trim();
    const v = normalizeEnvValue(trimmed.slice(eq + 1));
    out[k] = v;
  }
  return out;
}

function run(cmd, args, { cwd, captureStdout } = {}) {
  const res = spawnSync(cmd, args, {
    cwd,
    stdio: captureStdout ? ["inherit", "pipe", "inherit"] : "inherit",
    env: process.env,
    encoding: "utf8",
  });
  if (res.status !== 0) {
    const code = res.status ?? 1;
    throw new Error(`Command failed (${code}): ${cmd} ${args.join(" ")}`);
  }
  return captureStdout ? (res.stdout || "") : "";
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function getRepoRoot() {
  return path.resolve(path.dirname(new URL(import.meta.url).pathname), "..", "..");
}

function extractJsonObject(text) {
  const src = String(text || "");
  const start = src.lastIndexOf("{");
  const end = src.lastIndexOf("}");
  if (start === -1 || end === -1 || end <= start) return null;
  const candidate = src.slice(start, end + 1);
  try {
    return JSON.parse(candidate);
  } catch {
    return null;
  }
}

function findGateObjectDeep(value) {
  if (!value) return null;
  if (Array.isArray(value)) {
    for (const v of value) {
      const found = findGateObjectDeep(v);
      if (found) return found;
    }
    return null;
  }
  if (typeof value === "object") {
    const status = typeof value.status === "string" ? value.status.toUpperCase() : null;
    if ((status === "PASS" || status === "FAIL") && typeof value.summary === "string") {
      return {
        status,
        summary: value.summary,
        reason: typeof value.reason === "string" ? value.reason : undefined,
      };
    }
    for (const v of Object.values(value)) {
      const found = findGateObjectDeep(v);
      if (found) return found;
    }
  }
  if (typeof value === "string") {
    const parsed = extractJsonObject(value);
    if (parsed) return findGateObjectDeep(parsed);
  }
  return null;
}

function runConvex(repoRoot, fnId, payload) {
  const convexDir = path.join(repoRoot, "convex");
  const convexEnvLocal = path.join(convexDir, ".env.local");
  const envFileVars = readEnvFile(convexEnvLocal);
  if (!process.env.CONVEX_DEPLOYMENT && envFileVars.CONVEX_DEPLOYMENT) {
    process.env.CONVEX_DEPLOYMENT = normalizeEnvValue(envFileVars.CONVEX_DEPLOYMENT);
  }
  if (!process.env.CONVEX_URL && envFileVars.CONVEX_URL) {
    process.env.CONVEX_URL = normalizeEnvValue(envFileVars.CONVEX_URL);
  }

  if (process.env.CONVEX_DEPLOYMENT) {
    process.env.CONVEX_DEPLOYMENT = normalizeEnvValue(process.env.CONVEX_DEPLOYMENT);
  }

  const payloadJson = JSON.stringify(payload ?? {});
  const out = run("npx", ["convex", "run", fnId, payloadJson], { cwd: convexDir, captureStdout: true });
  return out.trim();
}

function getMissionMemoryContext(repoRoot, missionId) {
  try {
    const raw = runConvex(repoRoot, "documents.js:list", {});
    const docs = JSON.parse(raw);
    const doc = (docs || []).find((d) => d.type === "mission_memory" && d.missionId === missionId);
    if (!doc?.content) return "";
    const content = String(doc.content);
    // Keep prompt small: only latest slice.
    return content.length > 1400 ? content.slice(-1400) : content;
  } catch {
    return "";
  }
}

function appendMissionLearning(repoRoot, claim, gateJsonText) {
  if (!claim?.missionId) return;
  let gate = null;
  try {
    gate = findGateObjectDeep(JSON.parse(gateJsonText));
  } catch {
    gate = findGateObjectDeep(gateJsonText);
  }
  if (!gate) return;

  const line = `- [${new Date().toISOString()}] step=${claim.stepKey} role=${claim.role} status=${gate.status} summary=${gate.summary}${gate.reason ? ` reason=${gate.reason}` : ""}`;
  runConvex(repoRoot, "documents.js:appendMissionMemory", {
    missionId: claim.missionId,
    content: line,
    title: `Mission Memory: ${claim.runTitle}`,
  });
}

function executeWithOpenClaw({ repoRoot, claim }) {
  const sessionId = `clawscrew:${claim.runStepId}`;
  const role = claim.role || "runner";
  const missionMemory = getMissionMemoryContext(repoRoot, claim.missionId);
  const message = [
    `You are the ${role} runner for ClawsCrew workflow execution.`,
    `Run title: ${claim.runTitle}`,
    `Step: ${claim.stepKey}`,
    `Task: ${claim.taskTitle || claim.taskId}`,
    "",
    missionMemory
      ? `Mission memory context (latest):\n${missionMemory}`
      : "Mission memory context: (empty)",
    "",
    "Return ONLY a JSON object with this shape:",
    '{"status":"PASS|FAIL","summary":"short summary","reason":"optional reason"}',
    "",
    "If step succeeded, return PASS. If blocked/failed, return FAIL with reason.",
  ].join("\n");

  const out = run("openclaw", [
    "agent",
    "--session-id",
    sessionId,
    "--message",
    message,
    "--thinking",
    "low",
    "--json",
  ], { captureStdout: true });

  try {
    const parsed = JSON.parse(out);
    const gate = findGateObjectDeep(parsed);
    if (gate) return JSON.stringify(gate);
  } catch {
    // ignore parse failure and continue fallback strategies
  }

  const gateFromText = findGateObjectDeep(out) || extractJsonObject(out);
  if (gateFromText) return JSON.stringify(gateFromText);

  // fallback to FAIL if model output isn't parseable
  return JSON.stringify({
    status: "FAIL",
    summary: "Runner output was not valid gate JSON",
    reason: "Non-JSON response from OpenClaw agent",
  });
}

async function install({ dryRun }) {
  const repoRoot = path.resolve(path.dirname(new URL(import.meta.url).pathname), "..", "..");
  const uiEnvLocal = path.join(repoRoot, "ui", ".env.local");
  const convexDir = path.join(repoRoot, "convex");
  const convexEnvLocal = path.join(convexDir, ".env.local");

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  try {
    const vercelProject = (await question(rl, "Vercel project name (default: clawscrew): ")).trim() || "clawscrew";
    const adminEmail = (await question(rl, "Admin email (for login gate): ")).trim();
    const adminPassword = (await question(rl, "Admin password: ")).trim();
    let convexUrl = (await question(rl, "Convex URL (optional; press Enter to configure now): ")).trim();

    if (!convexUrl) {
      const ans = (await question(rl, "Run interactive Convex setup now? (Y/n): ")).trim().toLowerCase();
      const ok = ans === "" || ans === "y" || ans === "yes";
      if (ok) {
        process.stdout.write("\nStarting Convex interactive setup (this may prompt for login)...\n\n");
        run("npx", ["convex", "dev", "--once"], { cwd: convexDir });
        const env = readEnvFile(convexEnvLocal);
        convexUrl = env.CONVEX_URL || "";
        if (!convexUrl) {
          throw new Error(`Convex setup completed but ${convexEnvLocal} did not contain CONVEX_URL`);
        }
        process.stdout.write(`\nDetected Convex URL: ${convexUrl}\n\n`);
      }
    }

    const planned = {
      repoRoot,
      writeFiles: [uiEnvLocal],
      convex: {
        configured: !!convexUrl,
        envFile: convexEnvLocal,
      },
      vercel: {
        project: vercelProject,
        actions: [
          "vercel login (if needed)",
          `vercel link --project ${vercelProject} --yes`,
          "vercel env add NEXT_PUBLIC_CONVEX_URL production/preview/development",
          "vercel env add ADMIN_EMAIL production/preview/development",
          "vercel env add ADMIN_PASSWORD production/preview/development (sensitive)",
          "vercel deploy --prod --cwd ui",
        ],
        envVars: {
          NEXT_PUBLIC_CONVEX_URL: convexUrl || "<set after Convex setup>",
          ADMIN_EMAIL: adminEmail || "<required>",
          ADMIN_PASSWORD: adminPassword ? "<provided>" : "<required>",
        },
        rootDir: "ui",
        note: "For Git deployments, set Vercel Project Settings → Root Directory = ui",
      },
    };

    process.stdout.write("\nPlanned install actions:\n");
    process.stdout.write(JSON.stringify(planned, null, 2) + "\n\n");

    if (dryRun) {
      process.stdout.write("Dry run: no changes written.\n");
      return;
    }

    if (!adminEmail || !adminPassword) {
      process.stderr.write("ERROR: Admin email and password are required.\n");
      process.exitCode = 1;
      return;
    }

    ensureDir(path.dirname(uiEnvLocal));
    writeEnvFile(uiEnvLocal, {
      NEXT_PUBLIC_CONVEX_URL: convexUrl,
      ADMIN_EMAIL: adminEmail,
      ADMIN_PASSWORD: adminPassword,
      BETTER_AUTH_URL: "http://localhost:3000",
      BETTER_AUTH_SECRET: "",
    });

    process.stdout.write(`Wrote ${uiEnvLocal}\n\n`);
    process.stdout.write("\nConfiguring Vercel...\n\n");

    // Confirm vercel auth
    try {
      run("vercel", ["whoami"], { cwd: repoRoot });
    } catch {
      process.stdout.write("\nVercel login required. Run: vercel login\n\n");
      throw new Error("Not logged into Vercel");
    }

    // Link repo root to the Vercel project
    run("vercel", ["link", "--project", vercelProject, "--yes"], { cwd: repoRoot });

    const envs = ["production", "preview", "development"];
    for (const target of envs) {
      // From stdin: vercel env add NAME target --force --yes
      spawnSync("vercel", ["env", "add", "NEXT_PUBLIC_CONVEX_URL", target, "--force", "--yes"], {
        cwd: repoRoot,
        input: `${convexUrl}\n`,
        stdio: ["pipe", "inherit", "inherit"],
        env: process.env,
      });
      spawnSync("vercel", ["env", "add", "ADMIN_EMAIL", target, "--force", "--yes"], {
        cwd: repoRoot,
        input: `${adminEmail}\n`,
        stdio: ["pipe", "inherit", "inherit"],
        env: process.env,
      });
      spawnSync("vercel", ["env", "add", "ADMIN_PASSWORD", target, "--sensitive", "--force", "--yes"], {
        cwd: repoRoot,
        input: `${adminPassword}\n`,
        stdio: ["pipe", "inherit", "inherit"],
        env: process.env,
      });
    }

    process.stdout.write("\nTriggering a production deploy from ui/ ...\n\n");
    const deployOut = run("vercel", ["deploy", "--prod", "--cwd", "ui"], { cwd: repoRoot, captureStdout: true });
    const urlMatch = deployOut.match(/https:\/\/[a-z0-9-]+\.vercel\.app/gi);
    const deployedUrl = urlMatch ? urlMatch[urlMatch.length - 1] : null;

    process.stdout.write("\nSeeding + smoke checks...\n\n");
    // Load Convex deployment info from convex/.env.local
    const convexEnv = readEnvFile(convexEnvLocal);
    if (!convexEnv.CONVEX_DEPLOYMENT) {
      throw new Error(`Missing CONVEX_DEPLOYMENT in ${convexEnvLocal}`);
    }
    process.env.CONVEX_DEPLOYMENT = convexEnv.CONVEX_DEPLOYMENT;
    if (convexEnv.CONVEX_URL) process.env.CONVEX_URL = convexEnv.CONVEX_URL;

    // Seed (idempotent)
    run("npx", ["convex", "run", "seed:seedIfEmpty", "{}"], { cwd: convexDir });

    // Smoke check
    run("npx", ["convex", "run", "health:smoke", "{}"], { cwd: convexDir });

    process.stdout.write("\nInstall complete.\n");
    if (deployedUrl) {
      process.stdout.write(`Vercel URL: ${deployedUrl}\n`);
    }
    process.stdout.write(`Convex URL: ${convexUrl}\n`);

    process.stdout.write("\nNOTE: For GitHub-based deployments, set Vercel Project Settings → Root Directory = ui.\n");
  } finally {
    rl.close();
  }
}

async function connector({ once, pollMs, workerId, autoPass, executeOpenclaw, deployKey, deployment }) {
  const repoRoot = getRepoRoot();
  const effectivePollMs = Math.max(3000, Number(pollMs || 10000));
  const id = workerId || `connector-${process.pid}`;

  if (deployment) process.env.CONVEX_DEPLOYMENT = normalizeEnvValue(deployment);
  if (deployKey) process.env.CONVEX_DEPLOY_KEY = normalizeEnvValue(deployKey);

  process.stdout.write(`Starting connector as ${id} (poll ${effectivePollMs}ms)\n`);
  if (!process.env.CONVEX_DEPLOY_KEY) {
    process.stdout.write("Warning: CONVEX_DEPLOY_KEY is not set; commands may target a different deployment context.\n");
  }
  if (!autoPass && !executeOpenclaw) {
    process.stdout.write("Note: no executor selected. Claimed steps will be logged and then released.\n");
  }

  // eslint-disable-next-line no-constant-condition
  while (true) {
    try {
      const raw = runConvex(repoRoot, "connector.js:claimNext", { workerId: id });
      const parsed = raw ? JSON.parse(raw) : {};
      const claim = parsed.claim;

      if (!claim) {
        if (once) return;
        await sleep(effectivePollMs);
        continue;
      }

      process.stdout.write(`Claimed step ${claim.stepKey} (${claim.runStepId}) in run \"${claim.runTitle}\"\n`);

      if (autoPass) {
        const content = JSON.stringify({
          status: "PASS",
          summary: `Connector auto-pass for ${claim.stepKey}`,
          by: id,
        });

        runConvex(repoRoot, "connector.js:submitResult", {
          workerId: id,
          runStepId: claim.runStepId,
          content,
        });
        try {
          appendMissionLearning(repoRoot, claim, content);
        } catch (err) {
          process.stderr.write(`Mission memory append failed: ${String(err?.message || err)}\n`);
        }

        process.stdout.write(`Submitted PASS result for ${claim.runStepId}\n`);
      } else if (executeOpenclaw) {
        try {
          const content = executeWithOpenClaw({ repoRoot, claim });
          runConvex(repoRoot, "connector.js:submitResult", {
            workerId: id,
            runStepId: claim.runStepId,
            content,
          });
          try {
            appendMissionLearning(repoRoot, claim, content);
          } catch (err) {
            process.stderr.write(`Mission memory append failed: ${String(err?.message || err)}\n`);
          }
          process.stdout.write(`Submitted OpenClaw result for ${claim.runStepId}\n`);
        } catch (err) {
          const content = JSON.stringify({
            status: "FAIL",
            summary: `OpenClaw execution error on ${claim.stepKey}`,
            reason: String(err?.message || err),
          });
          runConvex(repoRoot, "connector.js:submitResult", {
            workerId: id,
            runStepId: claim.runStepId,
            content,
          });
          try {
            appendMissionLearning(repoRoot, claim, content);
          } catch (appendErr) {
            process.stderr.write(`Mission memory append failed: ${String(appendErr?.message || appendErr)}\n`);
          }
          process.stderr.write(`Submitted FAIL due to executor error for ${claim.runStepId}\n`);
        }
      } else {
        runConvex(repoRoot, "connector.js:releaseClaim", {
          workerId: id,
          runStepId: claim.runStepId,
        });
        process.stdout.write(`Released claim ${claim.runStepId} (dry execution)\n`);
      }

      if (once) return;
      await sleep(500);
    } catch (err) {
      process.stderr.write(`Connector loop error: ${String(err?.message || err)}\n`);
      if (once) throw err;
      await sleep(effectivePollMs);
    }
  }
}

async function connectorService({ dryRun, deployKey, deployment, pollMs, workerId, executeOpenclaw }) {
  const repoRoot = getRepoRoot();
  const convexEnv = readEnvFile(path.join(repoRoot, "convex", ".env.local"));
  const convexDeployment = normalizeEnvValue(deployment || process.env.CONVEX_DEPLOYMENT || convexEnv.CONVEX_DEPLOYMENT || "");
  const effectiveDeployKey = normalizeEnvValue(deployKey || process.env.CONVEX_DEPLOY_KEY || "");
  const effectivePollMs = Math.max(3000, Number(pollMs || 10000));
  const effectiveWorkerId = workerId || "connector-daemon";

  if (!convexDeployment) {
    throw new Error("Missing CONVEX_DEPLOYMENT (set env or convex/.env.local)");
  }
  if (!effectiveDeployKey) {
    throw new Error("Missing CONVEX_DEPLOY_KEY (pass --deploy-key or set env)");
  }

  const nodeBin = process.execPath;
  const scriptPath = path.join(repoRoot, "skill", "bin", "clawscrew");

  if (process.platform === "darwin") {
    const label = "ai.clawscrew.connector";
    const plistPath = path.join(process.env.HOME || "", "Library", "LaunchAgents", `${label}.plist`);
    ensureDir(path.dirname(plistPath));

    const args = [
      scriptPath,
      "connector",
      "--poll-ms",
      String(effectivePollMs),
      "--worker-id",
      effectiveWorkerId,
    ];
    if (executeOpenclaw) args.push("--execute-openclaw");

    const plist = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key><string>${label}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${nodeBin}</string>
    ${args.map((a) => `<string>${a}</string>`).join("\n    ")}
  </array>
  <key>EnvironmentVariables</key>
  <dict>
    <key>CONVEX_DEPLOYMENT</key><string>${convexDeployment}</string>
    <key>CONVEX_DEPLOY_KEY</key><string>${effectiveDeployKey}</string>
  </dict>
  <key>RunAtLoad</key><true/>
  <key>KeepAlive</key><true/>
  <key>StandardOutPath</key><string>${path.join(repoRoot, "logs", "connector.out.log")}</string>
  <key>StandardErrorPath</key><string>${path.join(repoRoot, "logs", "connector.err.log")}</string>
</dict>
</plist>
`;

    if (dryRun) {
      process.stdout.write(`Dry run: would write ${plistPath}\n`);
      return;
    }

    ensureDir(path.join(repoRoot, "logs"));
    fs.writeFileSync(plistPath, plist, "utf8");
    try {
      run("launchctl", ["unload", plistPath], { cwd: repoRoot, captureStdout: false });
    } catch {
      // ignore if not loaded yet
    }
    run("launchctl", ["load", plistPath], { cwd: repoRoot, captureStdout: false });
    process.stdout.write(`Installed connector service: ${plistPath}\n`);
    return;
  }

  if (process.platform === "linux") {
    const unitPath = path.join(repoRoot, "connector.service");
    const cmd = `${nodeBin} ${scriptPath} connector --poll-ms ${effectivePollMs} --worker-id ${effectiveWorkerId}${executeOpenclaw ? " --execute-openclaw" : ""}`;
    const unit = `[Unit]
Description=ClawsCrew Connector
After=network.target

[Service]
Type=simple
WorkingDirectory=${repoRoot}
Environment=CONVEX_DEPLOYMENT=${convexDeployment}
Environment=CONVEX_DEPLOY_KEY=${effectiveDeployKey}
ExecStart=${cmd}
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
`;
    if (dryRun) {
      process.stdout.write(`Dry run: would write ${unitPath}\n`);
      return;
    }
    fs.writeFileSync(unitPath, unit, "utf8");
    process.stdout.write(`Wrote ${unitPath}. Install with: sudo cp ${unitPath} /etc/systemd/system/clawscrew-connector.service && sudo systemctl daemon-reload && sudo systemctl enable --now clawscrew-connector\n`);
    return;
  }

  throw new Error(`Unsupported platform for connector-service: ${process.platform}`);
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const cmd = args._[0];
  if (!cmd) {
    usage();
    process.exit(1);
  }
  if (cmd === "install") {
    await install({ dryRun: !!args.dryRun });
    return;
  }
  if (cmd === "connector") {
    await connector({
      once: !!args.once,
      pollMs: args.pollMs,
      workerId: args.workerId,
      autoPass: !!args.autoPass,
      executeOpenclaw: !!args.executeOpenclaw,
      deployKey: args.deployKey,
      deployment: args.deployment,
    });
    return;
  }
  if (cmd === "connector-service") {
    await connectorService({
      dryRun: !!args.dryRun,
      deployKey: args.deployKey,
      deployment: args.deployment,
      pollMs: args.pollMs,
      workerId: args.workerId,
      executeOpenclaw: !!args.executeOpenclaw,
    });
    return;
  }

  usage();
  process.exit(1);
}

main().catch((err) => {
  process.stderr.write(String(err?.stack || err) + "\n");
  process.exit(1);
});
