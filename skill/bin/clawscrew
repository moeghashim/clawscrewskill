#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import readline from "node:readline";
import { spawnSync } from "node:child_process";

function usage() {
  process.stdout.write(`clawscrew

Usage:
  clawscrew install [--dry-run]
`);
}

function parseArgs(argv) {
  const args = { _: [] };
  for (const a of argv) {
    if (a === "--dry-run") args.dryRun = true;
    else args._.push(a);
  }
  return args;
}

function question(rl, prompt) {
  return new Promise((resolve) => rl.question(prompt, (ans) => resolve(ans)));
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function writeEnvFile(filePath, kv) {
  const lines = [];
  for (const [k, v] of Object.entries(kv)) {
    lines.push(`${k}=${v ?? ""}`);
  }
  lines.push("");
  fs.writeFileSync(filePath, lines.join("\n"), "utf8");
}

function readEnvFile(filePath) {
  if (!fs.existsSync(filePath)) return {};
  const out = {};
  const text = fs.readFileSync(filePath, "utf8");
  for (const line of text.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;
    const k = trimmed.slice(0, eq).trim();
    const v = trimmed.slice(eq + 1).trim();
    out[k] = v;
  }
  return out;
}

function run(cmd, args, { cwd, captureStdout } = {}) {
  const res = spawnSync(cmd, args, {
    cwd,
    stdio: captureStdout ? ["inherit", "pipe", "inherit"] : "inherit",
    env: process.env,
    encoding: "utf8",
  });
  if (res.status !== 0) {
    const code = res.status ?? 1;
    throw new Error(`Command failed (${code}): ${cmd} ${args.join(" ")}`);
  }
  return captureStdout ? (res.stdout || "") : "";
}

async function install({ dryRun }) {
  const repoRoot = path.resolve(path.dirname(new URL(import.meta.url).pathname), "..", "..");
  const uiEnvLocal = path.join(repoRoot, "ui", ".env.local");
  const convexDir = path.join(repoRoot, "convex");
  const convexEnvLocal = path.join(convexDir, ".env.local");

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  try {
    const vercelProject = (await question(rl, "Vercel project name (default: clawscrew): ")).trim() || "clawscrew";
    const adminEmail = (await question(rl, "Admin email (for login gate): ")).trim();
    const adminPassword = (await question(rl, "Admin password: ")).trim();
    let convexUrl = (await question(rl, "Convex URL (optional; press Enter to configure now): ")).trim();

    if (!convexUrl) {
      const ans = (await question(rl, "Run interactive Convex setup now? (Y/n): ")).trim().toLowerCase();
      const ok = ans === "" || ans === "y" || ans === "yes";
      if (ok) {
        process.stdout.write("\nStarting Convex interactive setup (this may prompt for login)...\n\n");
        run("npx", ["convex", "dev", "--once"], { cwd: convexDir });
        const env = readEnvFile(convexEnvLocal);
        convexUrl = env.CONVEX_URL || "";
        if (!convexUrl) {
          throw new Error(`Convex setup completed but ${convexEnvLocal} did not contain CONVEX_URL`);
        }
        process.stdout.write(`\nDetected Convex URL: ${convexUrl}\n\n`);
      }
    }

    const planned = {
      repoRoot,
      writeFiles: [uiEnvLocal],
      convex: {
        configured: !!convexUrl,
        envFile: convexEnvLocal,
      },
      vercel: {
        project: vercelProject,
        actions: [
          "vercel login (if needed)",
          `vercel link --project ${vercelProject} --yes`,
          "vercel env add NEXT_PUBLIC_CONVEX_URL production/preview/development",
          "vercel env add ADMIN_EMAIL production/preview/development",
          "vercel env add ADMIN_PASSWORD production/preview/development (sensitive)",
          "vercel deploy --prod --cwd ui",
        ],
        envVars: {
          NEXT_PUBLIC_CONVEX_URL: convexUrl || "<set after Convex setup>",
          ADMIN_EMAIL: adminEmail || "<required>",
          ADMIN_PASSWORD: adminPassword ? "<provided>" : "<required>",
        },
        rootDir: "ui",
        note: "For Git deployments, set Vercel Project Settings → Root Directory = ui",
      },
    };

    process.stdout.write("\nPlanned install actions:\n");
    process.stdout.write(JSON.stringify(planned, null, 2) + "\n\n");

    if (dryRun) {
      process.stdout.write("Dry run: no changes written.\n");
      return;
    }

    if (!adminEmail || !adminPassword) {
      process.stderr.write("ERROR: Admin email and password are required.\n");
      process.exitCode = 1;
      return;
    }

    ensureDir(path.dirname(uiEnvLocal));
    writeEnvFile(uiEnvLocal, {
      NEXT_PUBLIC_CONVEX_URL: convexUrl,
      ADMIN_EMAIL: adminEmail,
      ADMIN_PASSWORD: adminPassword,
      BETTER_AUTH_URL: "http://localhost:3000",
      BETTER_AUTH_SECRET: "",
    });

    process.stdout.write(`Wrote ${uiEnvLocal}\n\n`);
    process.stdout.write("\nConfiguring Vercel...\n\n");

    // Confirm vercel auth
    try {
      run("vercel", ["whoami"], { cwd: repoRoot });
    } catch {
      process.stdout.write("\nVercel login required. Run: vercel login\n\n");
      throw new Error("Not logged into Vercel");
    }

    // Link repo root to the Vercel project
    run("vercel", ["link", "--project", vercelProject, "--yes"], { cwd: repoRoot });

    const envs = ["production", "preview", "development"];
    for (const target of envs) {
      // From stdin: vercel env add NAME target --force --yes
      spawnSync("vercel", ["env", "add", "NEXT_PUBLIC_CONVEX_URL", target, "--force", "--yes"], {
        cwd: repoRoot,
        input: `${convexUrl}\n`,
        stdio: ["pipe", "inherit", "inherit"],
        env: process.env,
      });
      spawnSync("vercel", ["env", "add", "ADMIN_EMAIL", target, "--force", "--yes"], {
        cwd: repoRoot,
        input: `${adminEmail}\n`,
        stdio: ["pipe", "inherit", "inherit"],
        env: process.env,
      });
      spawnSync("vercel", ["env", "add", "ADMIN_PASSWORD", target, "--sensitive", "--force", "--yes"], {
        cwd: repoRoot,
        input: `${adminPassword}\n`,
        stdio: ["pipe", "inherit", "inherit"],
        env: process.env,
      });
    }

    process.stdout.write("\nTriggering a production deploy from ui/ ...\n\n");
    const deployOut = run("vercel", ["deploy", "--prod", "--cwd", "ui"], { cwd: repoRoot, captureStdout: true });
    const urlMatch = deployOut.match(/https:\/\/[a-z0-9-]+\.vercel\.app/gi);
    const deployedUrl = urlMatch ? urlMatch[urlMatch.length - 1] : null;

    process.stdout.write("\nSeeding + smoke checks...\n\n");
    // Load Convex deployment info from convex/.env.local
    const convexEnv = readEnvFile(convexEnvLocal);
    if (!convexEnv.CONVEX_DEPLOYMENT) {
      throw new Error(`Missing CONVEX_DEPLOYMENT in ${convexEnvLocal}`);
    }
    process.env.CONVEX_DEPLOYMENT = convexEnv.CONVEX_DEPLOYMENT;
    if (convexEnv.CONVEX_URL) process.env.CONVEX_URL = convexEnv.CONVEX_URL;

    // Seed
    run("npx", ["convex", "run", "seed:seedData", "{}"], { cwd: convexDir });

    // Smoke query
    run(
      "npx",
      ["convex", "run", "tasks:list", "{}"],
      {
        cwd: convexDir,
      }
    );

    process.stdout.write("\nInstall complete.\n");
    if (deployedUrl) {
      process.stdout.write(`Vercel URL: ${deployedUrl}\n`);
    }
    process.stdout.write(`Convex URL: ${convexUrl}\n`);

    process.stdout.write("\nNOTE: For GitHub-based deployments, set Vercel Project Settings → Root Directory = ui.\n");
  } finally {
    rl.close();
  }
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const cmd = args._[0];
  if (!cmd) {
    usage();
    process.exit(1);
  }
  if (cmd === "install") {
    await install({ dryRun: !!args.dryRun });
    return;
  }

  usage();
  process.exit(1);
}

main().catch((err) => {
  process.stderr.write(String(err?.stack || err) + "\n");
  process.exit(1);
});
